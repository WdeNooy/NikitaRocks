---
title: "Session 6. Predicting tie presence"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Regression basics, exposure, and our first analyses of pupil loudness.
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(knitr)
library(RColorBrewer) #for colour palettes
library(goldfish) #for relational events models
library(igraph) #for network visualization
library(ggraph) #for network visualization

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Standard colors to use
brewercolors <- brewer.pal( 5, name =  "Spectral")
brewercolors[3] <- "#ffff00"
names(brewercolors) <- c("Red", "Orange", "Yellow", "Green", "Blue")
#usage: colour = brewercolors["Blue"]

#load basic data
pupils_const <- NikitaRocks::pupils_const
pupils_dyn <- NikitaRocks::pupils_dyn
pairs_const <- NikitaRocks::pairs_const
pairs_dyn <- NikitaRocks::pairs_dyn

#load prepared analysis data sets
utterances <- NikitaRocks::utterances

# Create the data sets for predicting statements and playmate ties with the
# goldfish package.

# Step 1: The node set and time-constant node characteristics or starting values for time-varying node characteristics.
# - Nodes are identified by textual labels (required). 
# - variable 'present' (required) indicates if a pupil was already present at
#   the first time point.
# - Add time-constant node characteristics or starting values for time-varying
#   node characteristics (if any). These can be used as attributes in the
#   construction of predictors.
# The basic data set pupils_const contains all information.
nodes_pupils <- pupils_const %>% 
  #sort by label to ensure the same order in all networks
  arrange(label) %>%
  #select relevant variables.
  select(label, present, sex, ethnicity, adhd)
# Turn the data frame into a nodes.goldfish data object.
nodes_pupils <- defineNodes(nodes = nodes_pupils)
print("Showing data set nodes_pupils:")
as_tibble(nodes_pupils)

# Step 2: The changes to node attributes (if any, optional) over time.
# We do not have time-varying node attributes.
# If we had, we should ave used the linkEvents() function with arguments
# changeEvents and attribute.

# Step 3. The static or starting networks. 
# One network for each type of tie or event. One of these is the
# dependent/outcome network, all can be used as independent/predictor networks.
# All networks must have the same nodes as the nodes set and ordered as in the
# nodes set created in Step 1.
# - The initially empty directed network of statements.
net_statements <- defineNetwork(nodes = nodes_pupils, directed = TRUE)
# - The initially empty undirected network of playmates.
net_playmates <- defineNetwork(nodes = nodes_pupils, directed = FALSE)
# - The static undirected network of friendships.
#   For a static network, create a 0/1 matrix with rows and columns in the same
#   order as in the list of nodes.
#   The matrix columns must have the node labels as dimnames, but the rows do
#   not need to have dimnames.
friends_matrix <- pairs_const %>%
  #keep only the sender and receiver
  select(from, to, friend) %>%
  #add labels to IDs (so goldfish can match the matrix to the nodes)
  left_join(pupils_const[,c("ID", "label")], by = c("from" = "ID")) %>%
  left_join(pupils_const[,c("ID", "label")], by = c("to" = "ID")) %>%
  #label.x is sender, label.y is receiver: sort to match the nodes
  arrange(label.x, label.y) %>%
  #put 'to' values in columns
  pivot_wider(
    id_cols = label.x,
    names_from = label.y, #receiver provides the new columns (variables)
    values_from = friend, #variable friend indicates 0/1 friendship
    values_fill = 0, #replace missing values (e.g., on the diagonal) by 0
    names_sort = TRUE #ensure that the columns are in the correct order
    ) %>%
  #drop the from variable (row 1 has ID 1, etc.)
  select(-label.x) %>%
  #turn into a matrix
  as.matrix()
# create the undirected network of friendships
net_friends <- defineNetwork(matrix = friends_matrix, nodes = nodes_pupils, directed = FALSE)
print("Showing data set net_friends:")
as_tibble(net_friends)
# Cleanup.
rm(friends_matrix)

# Step 4. The events that happen to the networks. 
# Create a list of events for each network, indicating when an event starts or
# stops. Note: event start and end must become different rows (observations).
# One of these lists contains the events that we want to predict.
# Each events list must contain the variables: 
# - time: POSIXct, integer, or numeric (with decimals), 
# - sender: character label that occurs in nodes_pupils,
# - receiver: character label that occurs in nodes_pupils, 
# - increment: create (1) or dissolve (-1) event (numeric). Instead of
#   increment: replace, which updates the value of an attribute or tie (pair)?

# A. statement events
events_statements <- pairs_dyn %>%
  #select utterances in Break 1
  filter(dyntie == "Utterance" & breakID == 1) %>%
  #add labels to IDs (so goldfish can match the matrix to the nodes)
  left_join(pupils_const[,c("ID", "label")], by = c("from" = "ID")) %>%
  left_join(pupils_const[,c("ID", "label")], by = c("to" = "ID")) %>%
  #rename onset and terminus
  rename(
    onset.time = onset,
    terminus.time = terminus
  ) %>%
  #stack onset and terminus
  pivot_longer(
    cols = onset.time:terminus.censored,
    names_to = c("type", ".value"),
    names_sep = "\\.",
    values_drop_na = TRUE
  ) %>%
  #filter out censored end times (in case we want to predict end times)
  filter(!censored | type == "onset") %>%
  #recode increment into 1 for onset and -1 for terminus
  mutate(increment = ifelse(type == "onset", 1, -1)) %>%
  #select and rename relevant variables
  select(time, sender = label.x, receiver = label.y, increment) %>%
  #order by time
  arrange(time) %>%
  #a tibble throws a warning (in tutorial): Unknown or uninitialised column: `replace`.
  as.data.frame()
# link events to the network
net_statements <- linkEvents(x = net_statements, changeEvents = events_statements, nodes = nodes_pupils)
print("Showing data set events_statements:")
as_tibble(events_statements)

# B. playmate events
events_playmates <- pairs_dyn %>%
  #select playmate cases in Break 1 and only one row for each pair (undirected data)
  filter(dyntie == "Playmate" & breakID == 1 & from < to) %>%
  #add labels to IDs (so goldfish can match the matrix to the nodes)
  left_join(pupils_const[,c("ID", "label")], by = c("from" = "ID")) %>%
  left_join(pupils_const[,c("ID", "label")], by = c("to" = "ID")) %>%
  #rename onset and terminus
  rename(
    onset.time = onset,
    terminus.time = terminus
  ) %>%
  #stack onset and terminus
  pivot_longer(
    cols = onset.time:terminus.censored,
    names_to = c("type", ".value"),
    names_sep = "\\.",
    values_drop_na = TRUE
  ) %>%
  #filter out censored end times (there aren't any)
  filter(!censored | type == "onset") %>%
  #recode increment into 1 for onset and -1 for terminus
  mutate(increment = ifelse(
    type == "onset", 1, -1
  )) %>%
  #select and rename relevant variables
  select(time, sender = label.x, receiver = label.y, increment) %>%
  #order by time
  arrange(time) %>% #a tibble throws a warning (in tutorial): Unknown or uninitialised column: `replace`.
  as.data.frame()
# link events to the network
net_playmates <- linkEvents(x = net_playmates, changeEvents = events_playmates, nodes = nodes_pupils)
print("Showing data set events_playmates:")
as_tibble(events_playmates)
```

<!-- Define programming tip style -->
<style>
.tip {
  background-color: #f5f5f5;
}
</style>

<!-- Define question style -->
<style>
.question {
  color: #5A9DDB;
}
</style>


## Who will speak to whom?

In the preceding sessions, we have tried to predict a characteristic of a tie, namely, whether a statement from one pupil to another was positive or negative. 

we have assumed but not predicted that the ties (statements) exist. In the current session, we try to predict the presence versus absence of ties. Can we predict that a pupil says something to another pupil or starts playing with another pupil at a particular moment?

Basically, we are addressing network change: Can we predict how the structure of a network changes?

```{r fragment1plot1, fig.show='hold', fig.asp=1, out.width='50%'}
# Plot 1: snapshot from dynamic network in Break 1 including all pupils at time 22:28.
# Create nodes for all pupils.
nodes1 <- pupils_const %>%
  #add ? to pupil names
  mutate(label = paste0(label, "??"))
# Create edges Part 1: utterances and playmates in 5 minutes preceding 22:28.
edges1 <- pairs_dyn %>%
  #select all playmate ties and utterances that started (at most 5 minutes) before 22.4615385 in Break 1
  filter(
    breakID == 1 & #only in Break 1 (just to be sure)
    onset < 22.461 & #activity must start at or before the current timepoint...
    ((dyntie == "Utterance" & onset >= 22.4615385 - 5) | #...utterances must start at most 5 minutes before the current timepoint or... 
      (dyntie == "Playmate" & terminus >= 22.4615385)) & #...playmate tie must end at/after 22.4615385, and
    !(dyntie == "Playmate" & from >= to) #single playmate tie per pair
  ) %>%
  #recode negative to string for colouring
  mutate(
    negative = ifelse(negative == 1, "neg", "pos")
  )
# create edges Part 2: add friendships among selected pupils
edges1 <- pairs_const %>%
  #keep only 1 of 2 symmetric friendships
  filter(from < to & friend == "1") %>% 
  #add breakID, onset, terminus, and dyntie variable
  mutate(
    breakID = 1,
    dyntie = "Friendship"
  ) %>%
  #keep relevant variables
  select(from, to, breakID, dyntie) %>%
  #add to edges1
  bind_rows(edges1)
#create network (with igraph)
network1 <- graph_from_data_frame(edges1, directed = TRUE, vertices = nodes1)
#calculate layout (positions of nodes1)
net_layout1 <- create_layout(network1, layout = "igraph", algorithm = 'kk', dim = 2)
# create the network plot for this time point
ggraph(net_layout1) +
  geom_edge_link(
    aes(filter = (dyntie == "Friendship")),
    colour = "grey",
    alpha = 0.7,
    edge_width = 2.3
  ) +
  geom_edge_link(
    aes(filter = (dyntie == "Playmate")),
    colour = "black",
    edge_width = 0.7
  ) +
  geom_edge_fan(
    aes(
      filter = (dyntie == "Utterance"),
      alpha = (onset + 5 - 22.4615385)/5,
      colour = negative
    ),
    show.legend = FALSE,
    arrow = arrow(angle = 30, length = unit(3, "mm"), type = "closed"),
    end_cap = circle(4, 'mm'),
    edge_width = 1
  ) +
  geom_node_point(
    aes(fill = ethnicity, shape = ifelse(sex == 1, "girl", "boy")),
    size = 6,
    show.legend = FALSE
  ) +
  geom_node_point(
    aes(
      filter = (label == "Lauren")
    ),
    show.legend = FALSE,
    shape = 1,
    colour = brewercolors["Blue"],
    stroke = 2,
    size = 14
  ) +
  geom_node_text(aes(label = label), nudge_y = 0.1, vjust = 0, size = 4.5) +
  geom_text(
    label = paste0("Time ",
                   format(22, width = 2), ":",
                   formatC(round(60 * 0.4615385),
                           flag = "0", width=2)),
    x = max(net_layout1$x), y = max(net_layout1$y),
    hjust = 1, #aligned left
    vjust = 0, #aligned bottom
    size = 4.5
  ) +
  scale_edge_alpha("Edge direction", guide = "none") +
  scale_shape_manual(name = "Sex", values = c(22, 21)) +
  scale_fill_brewer(name = "Ethnicity", type = "div", palette = 1) +
  guides(fill = guide_legend(override.aes=list(shape=21))) + #bug fix
  scale_alpha(range = c(0.4, 0.8)) + #relative loudness, not absolute due to automatic rescaling
  scale_edge_color_manual(values = c(neg = brewercolors[["Red"]], pos = brewercolors[["Green"]])) +
  labs(subtitle = "Model 1: Who will speak?") +
  theme_void(base_size = 20)

# Plot 2: snapshot from dynamic network in Break 1 for statement by Lauren  at time 22:28.
#create the network for time point onset == 22.4615385, so it is available everywhere
# create edges Part 1: utterances and playmates
edges2 <- pairs_dyn %>%
  #select all playmate ties and utterances involving pupil 13 that started (at most 5 minutes) before 22.4615385 in Break 1
  filter(
    breakID == 1 & #only in Break 1 (just to be sure)
    onset < 22.461 & #activity must start at or before the current timepoint...
    ((dyntie == "Utterance" & onset >= 22.4615385 - 5) | #...utterances must start at most 5 minutes before the current timepoint or... 
      (dyntie == "Playmate" & terminus >= 22.4615385)) & #...playmate tie must end at/after 22.4615385, and ...
    (from == 13 | to == 13) & #sender or receiver must be Pupil 5 or 13
    !(dyntie == "Playmate" & from >= to) #single playmate tie per pair
  ) %>%
  #recode negative to string for colouring
  mutate(
    negative = ifelse(negative == 1, "neg", "pos")
  )
# create nodes from selected edges
nodes2 <- edges2 %>%
  #only keep ID variables
  select(from, to) %>%
  #stack the two variables
  pivot_longer(everything(), names_to = "x", values_to = "ID") %>%
  #keep one row per pupil and only ID variable
  group_by(ID) %>%
  summarise(.groups = "drop") %>%
  #add constant pupil characteristics
  left_join(pupils_const, by = "ID") %>%
  #add ? to pupils other than Lauren
  mutate(label = ifelse(label == "Lauren", label, paste0(label, "??")))
# create edges Part 2: add friendships among selected pupils
edges2 <- pairs_const %>%
  #select all friendships of selected pupils
  right_join(nodes2, by = c("from" = "ID")) %>%
  #keep friendships directed at selected nodes2
  right_join(nodes2, by = c("to" = "ID")) %>%
  #keep only 1 of 2 symmetric friendships
  filter(from < to) %>%
  #add breakID, onset, terminus, and dyntie variable
  mutate(
    breakID = 1,
    onset = onset.x,
    terminus = terminus.x,
    dyntie = "Friendship"
  ) %>%
  #keep relevant variables
  select(from, to, breakID, onset, terminus, dyntie) %>%
  #add to edges2
  bind_rows(edges2)
#create network (with igraph)
network2 <- graph_from_data_frame(edges2, directed = TRUE, vertices = nodes2)
#calculate layout (positions of nodes2)
net_layout2 <- create_layout(network2, layout = "igraph", algorithm = 'kk', dim = 2)
# create the network plot for this time point
ggraph(net_layout2) +
  geom_edge_link(
    aes(filter = (dyntie == "Friendship")),
    colour = "grey",
    alpha = 0.7,
    edge_width = 2.3
  ) +
  geom_edge_link(
    aes(filter = (dyntie == "Playmate")),
    colour = "black",
    edge_width = 0.7
  ) +
  geom_edge_fan(
    aes(
      filter = (dyntie == "Utterance"),
      alpha = (onset + 5 - 22.4615385)/5,
      colour = negative
    ),
    show.legend = FALSE,
    arrow = arrow(angle = 30, length = unit(3, "mm"), type = "closed"),
    end_cap = circle(4, 'mm'),
    edge_width = 1.5
  ) +
  geom_node_point(
    aes(fill = ethnicity, shape = ifelse(sex == 1, "girl", "boy")),
    size = 6,
    show.legend = FALSE
  ) +
  geom_node_point(
    aes(
      filter = (label == "Lauren")
    ),
    show.legend = FALSE,
    shape = 1,
    colour = brewercolors["Blue"],
    stroke = 2,
    size = 14
  ) +
  geom_node_text(aes(label = label), nudge_y = 0.1, vjust = 0, size = 4.5) +
  geom_text(
    label = paste0("Time ",
                   format(22, width = 2), ":",
                   formatC(round(60 * 0.4615385),
                           flag = "0", width=2)),
    x = max(net_layout2$x), y = max(net_layout2$y),
    hjust = 1, #aligned left
    vjust = 0, #aligned bottom
    size = 4.5
  ) +
  scale_edge_alpha("Edge direction", guide = "none") +
  scale_shape_manual(name = "Sex", values = c(22, 21)) +
  scale_fill_brewer(name = "Ethnicity", type = "div", palette = 1) +
  guides(fill = guide_legend(override.aes=list(shape=21))) + #bug fix
  scale_alpha(range = c(0.4, 0.8)) + #relative loudness, not absolute due to automatic rescaling
  scale_edge_color_manual(values = c(neg = brewercolors[["Red"]], pos = brewercolors[["Green"]])) +
  labs(subtitle = "Model 2: Lauren speaks to whom?") +
  theme_void(base_size = 20)

#Cleanup.
rm(nodes1, nodes2, edges1, edges2, network1, network2, net_layout1, net_layout2)
```

The prediction problem consists of two steps and models:

1. Predict who will act: the rate model. Actually, how often or how soon pupils act.
2. Predict towards whom will be acted: the (receiver) choice model.

Note that there is a third step, namely predicting the characteristics of a tie once we know who will send and receive the tie. We discussed this step in Session 5 (predicting tie valence).

## Install the `goldfish` package

We use the `goldfish` package to estimate models for predicting tie creation.

```{r installGoldfish, exercise = TRUE}
# Use this command to install the goldfish package from github.
remotes::install_github("snlab-ch/goldfish")
# Note: this requires the remotes package, which should be installed
# automatically when you install the NikitaRocks package.
```

<div class="question">
Exercises

1. Run the above code to install the `goldfish` package.

2. Replace the code by `?goldfish` and run this (should open new browser window with general info on the package), to check that installation was successful.
</div>

For installation problems (particularly on Mac OSX), consult https://github.com/snlab-ch/goldfish (https://github.com/snlab-ch/goldfish#installing-openmp-on-mac-osx).

## Build-in types of predictors

The `goldfish` package automatically creates the predictors for sender, receiver, (dis)similarity, other tie, same tie, and local network context effects that you chose. That saves us a lot of work!

Available effects:

Effect | Function | Description | Model 
:----- | :------- | :---------- | :----: 
Sender | ego(attribute) | tendency of actors to be more active when they score high on the attribute | rate
Receiver | alter(attribute) | tendency to chose alter when alter has a high score on the attribute | choice
*(Dis)similarity*: | | | 
- exact similarity | same(attribute) | tendency of an event happen if sender and receiver have the same attribute (homophily) | choice (one-mode only)
- approximate similarity | sim(attribute) | tendency of an event happen if sender and receiver have similar attribute values (homophily) | choice (one-mode only)
- dissimilarity | diff(attribute) | tendency of an event happen if sender and receiver have the different attribute values (heterophily) | choice (one-mode only) 
Other relation: | tie(network, weighted = FALSE, window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if a tie from sender to receiver exists in another relation (covariate network) | choice
*Same relation*: | | | 
- repetition | inertia(network, weighted = FALSE, window = Inf) | tendency to create an event from sender to receiver if this event happened before; tendency to update existing ties rather than creating new ones | choice
- reciprocity | recip(network, weighted = FALSE, window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if receiver sent events to sender before | choice (one-mode only) 
*Network context*: | | | 
- transitivity | trans(network, window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if it closes two-paths (sender->tertius->receiver) in the past events network | choice (one-mode only) 
- transitivity via two relations | mixedTrans(list(network1, network2), window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if it closes two-paths with events (sender->tertius) in network1 and (tertius->receiver) in network2 in the past events | choice (one-mode only) 
- four cycle | four(network, isTwoMode = FALSE, window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if they are connected via two intermediaries in the past events network | choice 
- embeddedness | node_trans(network, isTwoMode = FALSE, window = Inf, ignoreRep = FALSE) | tendency of an actor to create an event when s/he is the source in more transitive triangles (source->tertius->alter<-source) | rate 
- popularity (indegree) | indeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE) | rate model: tendency of an actor to create an event when s/he has received many events (same or other relation); choice model: tendency of an actor to be selected as event receiver when s/he has received many events (same or other relation) | rate & choice 
- activity (outdegree) | outdeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE) | rate model: tendency of an actor to create an event when s/he has sent many events (same or other relation); choice model: tendency of an actor to be selected as event receiver when s/he has sent many events (same or other relation) | rate & choice
*Network context and attribute*: | | | 
- connection to 'rich' neighbours | tertius(network, attribute, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE) | tendency of actors to be more active (rate model) or be selected (choice model) when their (incoming) network neighbours have (aggregated) higher values on the selected attribute | rate & choice
- connection to similar neighbours | tertius_diff(network, attribute, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE) | tendency of actors to be more active (rate model) or be selected (choice model) when their (incoming) network neighbours have more similar (?) values on the selected attribute | rate & choice

<div class="question">
Exercises

1. Which effects did we already encounter in Session 5?

2. Based on your knowledge of the world, do you expect that popularity (indegree) plays a role in predicting how often pupils make statements or to whom they make statements? Note that popularity (indegree) can refer to received statements but also to other received events or ties (friendship, current playmates).

3. Based again on your knowledge of the world, do you expect that transitivity plays a role in predicting how often pupils make statements or to whom they make statements?
</div>

###

### 

Some important additional arguments for predictor construction:

* `window`: Allows the user to set the length of the preceding <i class="question">time window</i> within which network ties/events are used to calculate the predictor. By default, all preceding ties or events are used (`Inf` for infinity).
* `weighted`: If set to `TRUE`, only checks the presence of the searched tie/event(s) (1 = Yes, 0 = No). If `FALSE` (default), counts the searched tie/event(s).
* `isTwoMode`: For some effects, th euser must specify whether the network is two-mode (`isTwoMode = TRUE`) or one-mode (`isTwoMode = FALSE`, default). 

## Data preparation for the `goldfish` package

Before we can estimate a model, we must create data objects in several steps:

1. The node set and time-constant node characteristics or starting values for time-varying node characteristics. 
2. The changes to node attributes (if any, optional) over time.
3. The static or starting networks. One network for each type of tie or event. One of these is the dependent/outcome network, all can be used as independent/predictor networks. All networks must have the same nodes as the nodes set and ordered as in the nodes set.
4. The events that happen to the networks. Create a list of events for each network, indicating when an event starts or stops. One of these lists contains the events that we want to predict.

The steps are explained in _Appendix: Data preparation_. As a result of these steps, we have:

1. A list of events that we want to predict: `events_statements`.
2. One or more networks that we can use to construct independent/predictor variables (see the previous topic): 
    + `net_friends`: static friendship relations amng pupils; 
    + `net_playmates`: network of playmates at time 0 linked to `events_playmates`; 
    +`net_statements`: network of statements at time 0 linked to `events_statements`.
3. A node list that may contain node characteristics, which can be used as attributes to construct independent/predictor variables (see the previous topic): `nodes_pupils` containing attributes `sex`, `ethnicity`, and `adhd`.

```{r inspect1, exercise = TRUE}
# Show data set (as a tibble).
as_tibble(nodes_pupils)
```

<div class="question">
Exercise

1. Adapt and run the above code to inspect all data sets that result from the data preparation steps. 
    + Some or not very informative; why?
    + Pay attention of the order of pupils in different data sets. What do you notice?
</div>

## Estimation with the `goldfish` package

In Dynamic Network Actor Models (DyNAMs), the two models are estimated separately. 

Let us first estimate the rate model: Can we predict the speed at which pupils make statements?

We can only use characteristics of the sending pupils to predict their statement speed (see the table in Topic <i class="question">Build-in types of predictors</i>): 

* Sender effects (`ego(attribute)`); 
* Sender's popularity (`indeg(network, isTwoMode)`) and activity (`outdeg(network, isTwoMode)`);
* embeddedness in transitive fragments (`node_trans(network, isTwoMode)`);
* connection to 'rich' neighbours (`tertius(network, attribute, isTwoMode)`);
* connection to similar neighbours (`tertius_diff(network, attribute, isTwoMode)`).

```{r ratemodel1, exercise = TRUE}
# Estimate the rate at which pupils make statements.
# Step 1: Define the dependent events
events_dependent <- defineDependentEvents(
  events = events_statements[events_statements$increment == 1,], #the event list that should be considered as a dependent variable in models: only statement starts
  nodes = nodes_pupils, #data frame or a nodes.goldfish object containing the nodes used in the event list
  defaultNetwork = net_statements #name of a goldfish network object
)
# Step 2: Estimate the rate model.
model_statement_rate <- estimate(
  events_dependent ~
    ego(nodes_pupils$sex) + 
    ego(nodes_pupils$adhd) + 
    indeg(net_statements, isTwoMode = FALSE, weighted = TRUE, window = 3) +
    indeg(net_friends, isTwoMode = FALSE),
    model = "DyNAM", subModel = "rate" #select the rate submodel
  )
summary(model_statement_rate)
```

<div class="question">
Exercises

1. 
</div>

{plus results interpretation; no predict() of confint() functions available}

Poisson model; (inverse) waiting time (rate function: speed): positive effects speed up, increase the probability of acting

### Estimate the (receiver) choice model

<div class="question">
Exercises

1. 
</div>

{plus results interpretation}

### Relational Events Model

In Relational Events Models (REMs), the rate and choice models are estimated at the same time.

<div class="question">
Exercises

1. 
</div>

### Playmate coordination

<div class="question">
Exercises

1. 
</div>

## `RSiena` for panel wave data

## Conclusion


## Further Reading


## Appendix: Data preparation

This is an advanced topic that you should probably only study if you start working with your own data. Nevertheless, the comments may help you understand the contents of the data that we need for `goldfish`.

```{r dataprep, exercise=TRUE}
# Create the data sets for predicting statements and playmate ties with the
# goldfish package.

# Step 1: The node set and time-constant node characteristics or starting values for time-varying node characteristics.
# - Nodes are identified by textual labels (required). 
# - variable 'present' (required) indicates if a pupil was already present at
#   the first time point.
# - Add time-constant node characteristics or starting values for time-varying
#   node characteristics (if any). These can be used as attributes in the
#   construction of predictors.
# The basic data set pupils_const contains all information.
nodes_pupils <- pupils_const %>% 
  #sort by label to ensure the same order in all networks
  arrange(label) %>%
  #select relevant variables.
  select(label, present, sex, ethnicity, adhd)
# Turn the data frame into a nodes.goldfish data object.
nodes_pupils <- defineNodes(nodes = nodes_pupils)
print("Showing data set nodes_pupils:")
as_tibble(nodes_pupils)

# Step 2: The changes to node attributes (if any, optional) over time.
# We do not have time-varying node attributes.
# If we had, we should ave used the linkEvents() function with arguments
# changeEvents and attribute.

# Step 3. The static or starting networks. 
# One network for each type of tie or event. One of these is the
# dependent/outcome network, all can be used as independent/predictor networks.
# All networks must have the same nodes as the nodes set and ordered as in the
# nodes set created in Step 1.
# - The initially empty directed network of statements.
net_statements <- defineNetwork(nodes = nodes_pupils, directed = TRUE)
# - The initially empty undirected network of playmates.
net_playmates <- defineNetwork(nodes = nodes_pupils, directed = FALSE)
# - The static undirected network of friendships.
#   For a static network, create a 0/1 matrix with rows and columns in the same
#   order as in the list of nodes.
#   The matrix columns must have the node labels as dimnames, but the rows do
#   not need to have dimnames.
friends_matrix <- pairs_const %>%
  #keep only the sender and receiver
  select(from, to, friend) %>%
  #add labels to IDs (so goldfish can match the matrix to the nodes)
  left_join(pupils_const[,c("ID", "label")], by = c("from" = "ID")) %>%
  left_join(pupils_const[,c("ID", "label")], by = c("to" = "ID")) %>%
  #label.x is sender, label.y is receiver: sort to match the nodes
  arrange(label.x, label.y) %>%
  #put 'to' values in columns
  pivot_wider(
    id_cols = label.x,
    names_from = label.y, #receiver provides the new columns (variables)
    values_from = friend, #variable friend indicates 0/1 friendship
    values_fill = 0, #replace missing values (e.g., on the diagonal) by 0
    names_sort = TRUE #ensure that the columns are in the correct order
    ) %>%
  #drop the from variable (row 1 has ID 1, etc.)
  select(-label.x) %>%
  #turn into a matrix
  as.matrix()
# create the undirected network of friendships
net_friends <- defineNetwork(matrix = friends_matrix, nodes = nodes_pupils, directed = FALSE)
print("Showing data set net_friends:")
as_tibble(net_friends)
# Cleanup.
rm(friends_matrix)

# Step 4. The events that happen to the networks. 
# Create a list of events for each network, indicating when an event starts or
# stops. Note: event start and end must become different rows (observations).
# One of these lists contains the events that we want to predict.
# Each events list must contain the variables: 
# - time: POSIXct, integer, or numeric (with decimals), 
# - sender: character label that occurs in nodes_pupils,
# - receiver: character label that occurs in nodes_pupils, 
# - increment: create (1) or dissolve (-1) event (numeric). Instead of
#   increment: replace, which updates the value of an attribute or tie (pair)?

# A. statement events
events_statements <- pairs_dyn %>%
  #select utterances in Break 1
  filter(dyntie == "Utterance" & breakID == 1) %>%
  #add labels to IDs (so goldfish can match the matrix to the nodes)
  left_join(pupils_const[,c("ID", "label")], by = c("from" = "ID")) %>%
  left_join(pupils_const[,c("ID", "label")], by = c("to" = "ID")) %>%
  #rename onset and terminus
  rename(
    onset.time = onset,
    terminus.time = terminus
  ) %>%
  #stack onset and terminus
  pivot_longer(
    cols = onset.time:terminus.censored,
    names_to = c("type", ".value"),
    names_sep = "\\.",
    values_drop_na = TRUE
  ) %>%
  #filter out censored end times (in case we want to predict end times)
  filter(!censored | type == "onset") %>%
  #recode increment into 1 for onset and -1 for terminus
  mutate(increment = ifelse(type == "onset", 1, -1)) %>%
  #select and rename relevant variables
  select(time, sender = label.x, receiver = label.y, increment) %>%
  #order by time
  arrange(time) %>%
  #a tibble throws a warning (in tutorial): Unknown or uninitialised column: `replace`.
  as.data.frame()
# link events to the network
net_statements <- linkEvents(x = net_statements, changeEvents = events_statements, nodes = nodes_pupils)
print("Showing data set events_statements:")
as_tibble(events_statements)

# B. playmate events
events_playmates <- pairs_dyn %>%
  #select playmate cases in Break 1 and only one row for each pair (undirected data)
  filter(dyntie == "Playmate" & breakID == 1 & from < to) %>%
  #add labels to IDs (so goldfish can match the matrix to the nodes)
  left_join(pupils_const[,c("ID", "label")], by = c("from" = "ID")) %>%
  left_join(pupils_const[,c("ID", "label")], by = c("to" = "ID")) %>%
  #rename onset and terminus
  rename(
    onset.time = onset,
    terminus.time = terminus
  ) %>%
  #stack onset and terminus
  pivot_longer(
    cols = onset.time:terminus.censored,
    names_to = c("type", ".value"),
    names_sep = "\\.",
    values_drop_na = TRUE
  ) %>%
  #filter out censored end times (there aren't any)
  filter(!censored | type == "onset") %>%
  #recode increment into 1 for onset and -1 for terminus
  mutate(increment = ifelse(
    type == "onset", 1, -1
  )) %>%
  #select and rename relevant variables
  select(time, sender = label.x, receiver = label.y, increment) %>%
  #order by time
  arrange(time) %>% #a tibble throws a warning (in tutorial): Unknown or uninitialised column: `replace`.
  as.data.frame()
# link events to the network
net_playmates <- linkEvents(x = net_playmates, changeEvents = events_playmates, nodes = nodes_pupils)
print("Showing data set events_playmates:")
as_tibble(events_playmates)
```

