---
title: "Session 6. Predicting tie presence"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Estimating the timing and targets of statements and playmates with the `goldfish` package.
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(knitr)
library(RColorBrewer) #for colour palettes
# library(goldfish) #for relational events models (installed and loaded during the session)
library(igraph) #for network visualization
library(ggraph) #for network visualization

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Standard colors to use
brewercolors <- brewer.pal( 5, name =  "Spectral")
brewercolors[3] <- "#ffff00"
names(brewercolors) <- c("Red", "Orange", "Yellow", "Green", "Blue")
#usage: colour = brewercolors["Blue"]

#load basic data
pupils_const <- NikitaRocks::pupils_const
pupils_dyn <- NikitaRocks::pupils_dyn
pairs_const <- NikitaRocks::pairs_const
pairs_dyn <- NikitaRocks::pairs_dyn

#load prepared analysis data sets
events_playmates <- NikitaRocks::events_playmates
events_statements <- NikitaRocks::events_statements
net_friends <- NikitaRocks::net_friends
net_playmates <- NikitaRocks::net_playmates
net_statements <- NikitaRocks::net_statements
nodes_pupils <- NikitaRocks::nodes_pupils
events_dependent <- NikitaRocks::events_dependent
events_play_dep <- NikitaRocks::events_play_dep
#load prepared analysis results
model_playmate_start <- NikitaRocks::model_playmate_start
model_statement_choice <- NikitaRocks::model_statement_choice
model_statement_rate <- NikitaRocks::model_statement_rate
model_statement_REM <- NikitaRocks::model_statement_REM
```

<!-- Define programming tip style -->
<style>
.tip {
  background-color: #f5f5f5;
}
</style>

<!-- Define question style -->
<style>
.question {
  color: #5A9DDB;
}
</style>


## Who will speak to whom?

In the preceding sessions, we have tried to predict a characteristic of a tie, namely, whether a statement from one pupil to another was positive or negative. 

we have assumed but not predicted that the ties (statements) exist. In the current session, we try to predict the presence versus absence of ties, more exactly, the events that ties appear (or disappear). Can we predict that a pupil says something to another pupil or starts playing with another pupil at a particular moment?

Basically, we are addressing network change: Can we predict how the structure of a network changes?

```{r fragment1plot1, fig.show='hold', fig.asp=1, out.width='50%'}
# Plot 1: snapshot from dynamic network in Break 1 including all pupils at time 22:28.
# Create nodes for all pupils.
nodes1 <- pupils_const %>%
  #add ? to pupil names
  mutate(label = paste0(label, "??"))
# Create edges Part 1: utterances and playmates in 5 minutes preceding 22:28.
edges1 <- pairs_dyn %>%
  #select all playmate ties and utterances that started (at most 5 minutes) before 22.4615385 in Break 1
  filter(
    breakID == 1 & #only in Break 1 (just to be sure)
    onset < 22.461 & #activity must start at or before the current timepoint...
    ((dyntie == "Utterance" & onset >= 22.4615385 - 5) | #...utterances must start at most 5 minutes before the current timepoint or... 
      (dyntie == "Playmate" & terminus >= 22.4615385)) & #...playmate tie must end at/after 22.4615385, and
    !(dyntie == "Playmate" & from >= to) #single playmate tie per pair
  ) %>%
  #recode negative to string for colouring
  mutate(
    negative = ifelse(negative == 1, "neg", "pos")
  )
# create edges Part 2: add friendships among selected pupils
edges1 <- pairs_const %>%
  #keep only 1 of 2 symmetric friendships
  filter(from < to & friend == "1") %>% 
  #add breakID, onset, terminus, and dyntie variable
  mutate(
    breakID = 1,
    dyntie = "Friendship"
  ) %>%
  #keep relevant variables
  select(from, to, breakID, dyntie) %>%
  #add to edges1
  bind_rows(edges1)
#create network (with igraph)
network1 <- graph_from_data_frame(edges1, directed = TRUE, vertices = nodes1)
#calculate layout (positions of nodes1)
net_layout1 <- create_layout(network1, layout = "igraph", algorithm = 'kk', dim = 2)
# create the network plot for this time point
ggraph(net_layout1) +
  geom_edge_link(
    aes(filter = (dyntie == "Friendship")),
    colour = "grey",
    alpha = 0.7,
    edge_width = 2.3
  ) +
  geom_edge_link(
    aes(filter = (dyntie == "Playmate")),
    colour = "black",
    edge_width = 0.7
  ) +
  geom_edge_fan(
    aes(
      filter = (dyntie == "Utterance"),
      alpha = (onset + 5 - 22.4615385)/5,
      colour = negative
    ),
    show.legend = FALSE,
    arrow = arrow(angle = 30, length = unit(3, "mm"), type = "closed"),
    end_cap = circle(4, 'mm'),
    edge_width = 1
  ) +
  geom_node_point(
    aes(fill = ethnicity, shape = ifelse(sex == 1, "girl", "boy")),
    size = 6,
    show.legend = FALSE
  ) +
  geom_node_point(
    aes(
      filter = (label == "Lauren")
    ),
    show.legend = FALSE,
    shape = 1,
    colour = brewercolors["Blue"],
    stroke = 2,
    size = 14
  ) +
  geom_node_text(aes(label = label), nudge_y = 0.1, vjust = 0, size = 4.5) +
  geom_text(
    label = paste0("Time ",
                   format(22, width = 2), ":",
                   formatC(round(60 * 0.4615385),
                           flag = "0", width=2)),
    x = max(net_layout1$x), y = max(net_layout1$y),
    hjust = 1, #aligned left
    vjust = 0, #aligned bottom
    size = 4.5
  ) +
  scale_edge_alpha("Edge direction", guide = "none") +
  scale_shape_manual(name = "Sex", values = c(22, 21)) +
  scale_fill_brewer(name = "Ethnicity", type = "div", palette = 1) +
  guides(fill = guide_legend(override.aes=list(shape=21))) + #bug fix
  scale_alpha(range = c(0.4, 0.8)) + #relative loudness, not absolute due to automatic rescaling
  scale_edge_color_manual(values = c(neg = brewercolors[["Red"]], pos = brewercolors[["Green"]])) +
  labs(subtitle = "Model 1: Who will speak?") +
  theme_void(base_size = 20)

# Plot 2: snapshot from dynamic network in Break 1 for statement by Lauren  at time 22:28.
#create the network for time point onset == 22.4615385, so it is available everywhere
# create edges Part 1: utterances and playmates
edges2 <- pairs_dyn %>%
  #select all playmate ties and utterances involving pupil 13 that started (at most 5 minutes) before 22.4615385 in Break 1
  filter(
    breakID == 1 & #only in Break 1 (just to be sure)
    onset < 22.461 & #activity must start at or before the current timepoint...
    ((dyntie == "Utterance" & onset >= 22.4615385 - 5) | #...utterances must start at most 5 minutes before the current timepoint or... 
      (dyntie == "Playmate" & terminus >= 22.4615385)) & #...playmate tie must end at/after 22.4615385, and ...
    (from == 13 | to == 13) & #sender or receiver must be Pupil 5 or 13
    !(dyntie == "Playmate" & from >= to) #single playmate tie per pair
  ) %>%
  #recode negative to string for colouring
  mutate(
    negative = ifelse(negative == 1, "neg", "pos")
  )
# create nodes from selected edges
nodes2 <- edges2 %>%
  #only keep ID variables
  select(from, to) %>%
  #stack the two variables
  pivot_longer(everything(), names_to = "x", values_to = "ID") %>%
  #keep one row per pupil and only ID variable
  group_by(ID) %>%
  summarise(.groups = "drop") %>%
  #add constant pupil characteristics
  left_join(pupils_const, by = "ID") %>%
  #add ? to pupils other than Lauren
  mutate(label = ifelse(label == "Lauren", label, paste0(label, "??")))
# create edges Part 2: add friendships among selected pupils
edges2 <- pairs_const %>%
  #select all friendships of selected pupils
  right_join(nodes2, by = c("from" = "ID")) %>%
  #keep friendships directed at selected nodes2
  right_join(nodes2, by = c("to" = "ID")) %>%
  #keep only 1 of 2 symmetric friendships
  filter(from < to) %>%
  #add breakID, onset, terminus, and dyntie variable
  mutate(
    breakID = 1,
    onset = onset.x,
    terminus = terminus.x,
    dyntie = "Friendship"
  ) %>%
  #keep relevant variables
  select(from, to, breakID, onset, terminus, dyntie) %>%
  #add to edges2
  bind_rows(edges2)
#create network (with igraph)
network2 <- graph_from_data_frame(edges2, directed = TRUE, vertices = nodes2)
#calculate layout (positions of nodes2)
net_layout2 <- create_layout(network2, layout = "igraph", algorithm = 'kk', dim = 2)
# create the network plot for this time point
ggraph(net_layout2) +
  geom_edge_link(
    aes(filter = (dyntie == "Friendship")),
    colour = "grey",
    alpha = 0.7,
    edge_width = 2.3
  ) +
  geom_edge_link(
    aes(filter = (dyntie == "Playmate")),
    colour = "black",
    edge_width = 0.7
  ) +
  geom_edge_fan(
    aes(
      filter = (dyntie == "Utterance"),
      alpha = (onset + 5 - 22.4615385)/5,
      colour = negative
    ),
    show.legend = FALSE,
    arrow = arrow(angle = 30, length = unit(3, "mm"), type = "closed"),
    end_cap = circle(4, 'mm'),
    edge_width = 1.5
  ) +
  geom_node_point(
    aes(fill = ethnicity, shape = ifelse(sex == 1, "girl", "boy")),
    size = 6,
    show.legend = FALSE
  ) +
  geom_node_point(
    aes(
      filter = (label == "Lauren")
    ),
    show.legend = FALSE,
    shape = 1,
    colour = brewercolors["Blue"],
    stroke = 2,
    size = 14
  ) +
  geom_node_text(aes(label = label), nudge_y = 0.1, vjust = 0, size = 4.5) +
  geom_text(
    label = paste0("Time ",
                   format(22, width = 2), ":",
                   formatC(round(60 * 0.4615385),
                           flag = "0", width=2)),
    x = max(net_layout2$x), y = max(net_layout2$y),
    hjust = 1, #aligned left
    vjust = 0, #aligned bottom
    size = 4.5
  ) +
  scale_edge_alpha("Edge direction", guide = "none") +
  scale_shape_manual(name = "Sex", values = c(22, 21)) +
  scale_fill_brewer(name = "Ethnicity", type = "div", palette = 1) +
  guides(fill = guide_legend(override.aes=list(shape=21))) + #bug fix
  scale_alpha(range = c(0.4, 0.8)) + #relative loudness, not absolute due to automatic rescaling
  scale_edge_color_manual(values = c(neg = brewercolors[["Red"]], pos = brewercolors[["Green"]])) +
  labs(subtitle = "Model 2: Lauren speaks to whom?") +
  theme_void(base_size = 20)

#Cleanup.
rm(nodes1, nodes2, edges1, edges2, network1, network2, net_layout1, net_layout2)
```

The prediction problem consists of two steps and models:

1. Predict who will act: the rate model. Actually, how often or how soon pupils act.
2. Predict towards whom will be acted: the (receiver) choice model.

Note that there is a third step, namely predicting the characteristics of an action (such as maintaining a tie) once we know who will send and receive the action. We discussed this step in Session 5 (predicting tie valence).

## Install the `goldfish` package

We use the `goldfish` package to estimate models for predicting interactions or tie creation/dissolution.

```{r installGoldfish, eval=FALSE, echo=TRUE}
# COPY THIS COMMANDS TO THE RStudio CONSOLE AND RUN IT THERE. This will install
# the goldfish package from github.
remotes::install_github("snlab-ch/goldfish")
# Note: this requires the remotes package, which has been  installed
# automatically when you install the NikitaRocks package.
```

<div class="question">
Exercises

1. Run the above code in the RStudio console to install the `goldfish` package.

```{r loadGoldfish, exercise = TRUE}
# Load the goldfish package.
library(goldfish)
# And check correct installation and loading.
?goldfishEffects
```

2. Run the above code. This should display info on the package (perhaps in a new browser window).
</div>

For installation problems (particularly on Mac OSX), consult https://github.com/snlab-ch/goldfish (https://github.com/snlab-ch/goldfish#installing-openmp-on-mac-osx).

## Build-in types of predictors

The `goldfish` package automatically creates the predictors for sender, receiver, (dis)similarity, other tie, same tie, and local network context effects that you chose. That saves us a lot of work!

Available effects:

Effect | Function | Description | Model 
:----- | :------- | :---------- | :----: 
Sender | ego(attribute) | tendency of actors to be more active when they score high on the attribute | rate
Receiver | alter(attribute) | tendency to chose alter when alter has a high score on the attribute | choice
*(Dis)similarity*: | | | 
- exact similarity | same(attribute) | tendency of an event happen if sender and receiver have the same attribute (homophily) | choice (one-mode only)
- approximate similarity | sim(attribute) | tendency of an event happen if sender and receiver have similar attribute values (homophily) | choice (one-mode only)
- dissimilarity | diff(attribute) | tendency of an event happen if sender and receiver have the different attribute values (heterophily) | choice (one-mode only) 
Other relation: | tie(network, weighted = FALSE, window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if a tie from sender to receiver exists in another relation (covariate network) | choice
*Same relation*: | | | 
- repetition | inertia(network, weighted = FALSE, window = Inf) | tendency to create an event from sender to receiver if this event happened before; tendency to update existing ties rather than creating new ones | choice
- reciprocity | recip(network, weighted = FALSE, window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if receiver sent events to sender before | choice (one-mode only) 
*Network context*: | | | 
- transitivity | trans(network, window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if it closes two-paths (sender->tertius->receiver) in the past events network | choice (one-mode only) 
- transitivity via two relations | mixedTrans(list(network1, network2), window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if it closes two-paths with events (sender->tertius) in network1 and (tertius->receiver) in network2 in the past events | choice (one-mode only) 
- four cycle | four(network, isTwoMode = FALSE, window = Inf, ignoreRep = FALSE) | tendency to create an event from sender to receiver if they are connected via two intermediaries in the past events network | choice 
- embeddedness | node_trans(network, isTwoMode = FALSE, window = Inf, ignoreRep = FALSE) | tendency of an actor to create an event when s/he is the source in more transitive triangles (source->tertius->alter<-source) | rate 
- popularity (indegree) | indeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE) | rate model: tendency of an actor to create an event when s/he has received many events (same or other relation); choice model: tendency of an actor to be selected as event receiver when s/he has received many events (same or other relation) | rate & choice 
- activity (outdegree) | outdeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE) | rate model: tendency of an actor to create an event when s/he has sent many events (same or other relation); choice model: tendency of an actor to be selected as event receiver when s/he has sent many events (same or other relation) | rate & choice
*Network context and attribute*: | | | 
- connection to 'rich' neighbours | tertius(network, attribute, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE) | tendency of actors to be more active (rate model) or be selected (choice model) when their (incoming) network neighbours have (aggregated) higher values on the selected attribute | rate & choice
- connection to similar neighbours | tertius_diff(network, attribute, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE) | tendency of actors to be more active (rate model) or be selected (choice model) when their (incoming) network neighbours have more similar (?) values on the selected attribute | rate & choice

<div class="question">
Exercises

1. Which effects did we already encounter in Session 5?

2. Based on your knowledge of the world, do you expect that popularity (indegree) plays a role in predicting how often pupils make statements or to whom they make statements? Note that popularity (indegree) can refer to received statements but also to other received events or ties (friendship, current playmates).

3. Based again on your knowledge of the world, do you expect that transitivity plays a role in predicting how often pupils make statements or to whom they make statements?
</div>

###

### 

Arguments for predictor construction:

* `isTwoMode`: For some effects, we must specify whether the network is two-mode (`isTwoMode = TRUE`) or one-mode (`isTwoMode = FALSE`, default). 
* `weighted`: If set to `TRUE`, only checks the presence of the searched tie/interaction(s) (1 = Yes, 0 = No). If `FALSE` (default), counts the searched tie/interaction(s).
* `window`: Allows the user to set the length of the preceding <i class="question">time window</i> within which network ties/interactions are used to calculate the predictor. By default, all preceding ties or interactions are used (`Inf` for infinity).
* `ignoreRep`: If an actor sends more than one tie/interaction to a receiver within the time window, take into account only the first tie/interaction (`ignoreRep = TRUE`) or all ties/interactions (`ignoreRep = FALSE`, default)

## Data preparation

Before we can estimate a model with the `goldfish` package, we must create data objects in several steps:

1. The node set and time-constant node characteristics or starting values for time-varying node characteristics. 
2. The changes to node attributes (if any, optional) over time.
3. The static or starting networks. One network for each type of tie or interaction. One of these is the dependent/outcome network, all can be used as independent/predictor networks. All networks must have the same nodes as the nodes set and ordered as in the nodes set.
4. The events that happen to the networks. Create a list of events for each network, indicating when an event starts or stops. One of these lists contains the events that we want to predict.

The steps are explained in _Appendix: Data preparation_. As a result of these steps, we have:

1. A list of events that we want to predict: `events_dependent`.
2. One or more networks that we can use to construct independent/predictor variables (see the previous topic): 
    + `net_friends`: static friendship relations amng pupils; 
    + `net_playmates`: network of playmates at time 0 linked to `events_playmates`; 
    + `net_statements`: network of statements at time 0 linked to `events_statements`.
3. A node list that may contain node characteristics, which can be used as attributes to construct independent/predictor variables (see the previous topic): `nodes_pupils` containing attributes `sex`, `ethnicity`, and `adhd`.

```{r inspect1, exercise = TRUE}
# Show data set (as a tibble).
as_tibble(nodes_pupils)
```

<div class="question">
Exercise

1. Adapt and run the above code to inspect all data sets that result from the data preparation steps. 
    + Some or not very informative; why?
    + Pay attention of the order of pupils in different data sets. What do you notice?
</div>

## Estimating the (sender) rate model

In Dynamic Network Actor Models (DyNAMs), the two models are estimated separately. 

Let us first estimate the rate model: Can we predict the speed at which pupils make statements?

We can only use characteristics of the sending pupils to predict their statement speed (see the table in Topic <i class="question">Build-in types of predictors</i>):

* Sender effects (`ego(attribute)`); 
* Sender's popularity (`indeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE)`) and activity (`outdeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE)`);
* embeddedness in transitive fragments (`node_trans(network, isTwoMode = FALSE, window = Inf, ignoreRep = FALSE)`);
* connection to 'rich' neighbours (`tertius(network, attribute, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE)`);
* connection to similar neighbours (`tertius_diff(network, attribute, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE)`).

```{r ratemodel1, exercise = TRUE, exercise.timelimit = 180}
# Estimate the rate at which pupils make statements.
# Step 1: Define the dependent events
events_dependent <- defineDependentEvents(
  events = events_statements[events_statements$increment == 1,], #the event list that should be considered as a dependent variable in models: we only analyze statement starts
  nodes = nodes_pupils, #data frame or a nodes.goldfish object containing the nodes used in the event list
  defaultNetwork = net_statements #name of a goldfish network object
)
# NOTE: Within the tutorial, changes to the code of Step 1 are ignored.
# Step 2: Estimate the rate model.
model_statement_rate <- estimate(
  events_dependent ~ 1 + #an intercept is not automatically added!
    ego(nodes_pupils$sex) + 
    ego(nodes_pupils$adhd) + 
    indeg(net_statements, isTwoMode = FALSE, weighted = TRUE, window = 3) +
    indeg(net_friends, isTwoMode = FALSE),
    model = "DyNAM", subModel = "rate" #select the rate submodel
  )
summary(model_statement_rate)
```

<div class="question">
Exercises

1. Inspect the code of Step 2. Which effects are estimated and what do the arguments mean?

2. Run the code (may take some time; alternative: only run the summary() function) and inspect the output (in the last output box). Interpret the signs (directions) of the coefficients: What speeds up making statements and what slows it down?

3. Estimate some more models, adding/removing effects and changing arguments.
</div>

### Interpreting results

Unfortunately, the `goldfish` package does not have `confint() ` or `predict()` functions (at the moment of writing this tutorial). 

For our confidence in the sign (direction) of effects, we can use the stars printed next to the `Pr(>|z|)` column in the results output. If there is at least one star, we are (95%) confident of the sign of the effect.

In general we can say that:

* A positive effect 'speeds up' making statements, hence reduces the predicted waiting time between a pupil's statements;
* A negative effect 'slows down' making statements, hence increases the predicted waiting time between a pupil's statements;

The size of effects are not easy to interpret. If you are eager to know, study the next subtopic. Otherwise, skip it.

### Effect size details (only for enthusiasts)

The model (for the curious: a Poisson regression model) predicts the logarithm of the rate at which pupils make statements.

We must exponentiate an effect to get the predicted percentage change in the rate (for a 1 unit increase in the predictor).

```{r interpretrate1, exercise = TRUE}
# For the original rate model:
print("Predicted percentage change in the rate:")
exp(coef(model_statement_rate))
# If we take the inverse of the exponentiated effects, we get the predicted
# percentage change in the waiting time between statements (for a 1 unit
# increase in the predictor).
1 / exp(coef(model_statement_rate))
```

If we take the inverse of the exponentiated effects, we get the predicted percentage change in the waiting time between statements (for a 1 unit increase in the predictor).

```{r interpretrate2, exercise = TRUE}
# For the original rate model:
print("Predicted percentage change in the waiting time:")
1 / exp(coef(model_statement_rate))
```

Percentage change examples:

* 1.099: a (100 * (1.099 - 1) =) 9.9 percent increase;
* 0.845: a (100 * (1 - 0.845) =) 15.5 percent decrease.

<div class="question">
Exercise

1. Interpret the predicted percentage change in the rate and waiting time for the four predictor variables.
</div>

## Estimating the (receiver) choice model

For predicting the receiver of the tie or interaction, we can use all predictors that include the receiver:

* Receiver effects (`alter(attribute)`);
* Exact similarity effects (`same(attribute)`);
* Approximate similarity effects: (`sim(attribute)`);
* Dissimilarity effects (`diff(attribute)`);
* Other relation effects (`tie(network, weighted = FALSE, window = Inf, ignoreRep = FALSE)`);
* Repetition effects (`inertia(network, weighted = FALSE, window = Inf)`);
* Reciprocity effects (`recip(network, weighted = FALSE, window = Inf, ignoreRep = FALSE)`);
* Transitivity effects (`trans(network, window = Inf, ignoreRep = FALSE)`); 
* Transitivity via two relations effects (`mixedTrans(list(network1, network2), window = Inf, ignoreRep = FALSE)`); 
* Four cycle effects (`four(network, isTwoMode = FALSE, window = Inf, ignoreRep = FALSE)`); 
* Popularity (indegree) effects (`indeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE)`); 
* Activity (outdegree) effects (`outdeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE)`);
* Connection to 'rich' neighbours effects (`tertius(network, attribute, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE)`);
* Connection to similar neighbours effects (`tertius_diff(network, attribute, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE)`).

```{r choicemodel1, exercise = TRUE, exercise.timelimit = 180}
# Estimate the receiver of the statements that pupils make.
# Step 1: Define the dependent events. Same as rate model (see there).
# Step 2: Estimate the choice model.
model_statement_choice <- estimate(
  events_dependent ~ #do not use an intercept in a choice model!
    sim(nodes_pupils$adhd) + 
    tie(net_playmates, weighted = FALSE, window = 1, ignoreRep = TRUE) +
    recip(net_statements, weighted = TRUE, window = 3, ignoreRep = FALSE),
    model = "DyNAM", subModel = "choice" #select the choice submodel
  )
summary(model_statement_choice)
```

<div class="question">
Exercises

1. Inspect the code of Step 2. Which effects are estimated and what do the arguments mean?

2. Run the code (may take some time; alternative: only run the summary() function) and inspect the output (in the last output box). Interpret the signs (directions) of the coefficients: What increases the probability that a pupil is selected as statement target, what decreases it?

3. Estimate some more models, adding/removing effects and changing arguments.
</div>

### Interpreting results

As with the results of the rate model, we can base our confidence of the sign (direction) of effects on the statistical significance of results (stars to the `Pr(>|z|)` column in the results output).

Generally speaking, a positive effect increases the chance that a pupil is selected as statement target, whereas a negative effect decreases it. The particulars are for enthusiasts only (next subtopic).

### Effect size details (only for enthusiasts)

The model (for the curious: a multinomial regression model) predicts the log odds of the probability that a pupil is selected as statement target, just like a logistic regression model.

We can get the predicted odds (relative probability of being selected as statement target, that is, predicted probability of being selected over not being selected) by exponentiating the regression coefficients. 

The resulting value tells how much more likely pupils are the statement target if they score one unit higher on the predictor variable (with all other predictors at zero).

```{r interpretchoice1, exercise = TRUE}
# For the original choice model: 
exp(coef(model_statement_choice))
```

For example, pupils who are one unit more similar to the speaker (sender) are around `r round(exp(model_statement_choice$parameters[[1]]))` more likely to be selected as target (if they are not playmate of the speaker and did not make statements to the speaker in the preceding 3 minutes).

This looks like an incredibly large effect. Unfortunately, we do not know the scale of the similarity variable. Perhaps one unit represents an unrealistically huge change in the similarity score.

<div class="question">
Exercise

1. Run the code and interpret the results for the other effects.
</div>

## Relational Events Model

Relational Events Modes (REMs) offer an alternative (and precursor) to the separate estimation of rate and choice models. In a REM, both models are estimated at the same time.

A REM evaluates all possible arrows that may appear at a time point. It predicts which of these is most likely to appear given the state of the network: previous arrows (for example, statements), other relations (for example, friendship, playmates), speaker and target characteristics, and (dis)similarities between these.

As a consequence, we can use all types of effects from the `goldfish` package. For effects that may address the sender and receiver, we must use the `type = "ego"` or `type = "alter"` argument to clarify which of the two we mean:

* popularity (indegree): `indeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE, type = c("alter", "ego"))`;
* activity (outdegree): `outdeg(network, isTwoMode = FALSE, weighted = FALSE, window = Inf, ignoreRep = FALSE, type = c("alter", "ego"))`;
* embeddedness: `node_trans(network, isTwoMode = FALSE, window = Inf, ignoreRep = FALSE, type = c("alter", "ego"))`.

We can estimate REMs with the `goldfish` package (as well as with the `relevent` package).

```{r rem, exercise = TRUE, exercise.timelimit = 300}
# Estimate the receiver of the statements that pupils make.
# NOTE: ESTIMATION MAY TAKE QUITE SOME TIME.
# Step 1: Define the dependent events. Same as the rate model (see there).
# Step 2: Estimate the choice model.
model_statement_REM <- estimate(
  events_dependent ~ 1 + #an intercept is not automatically added!
    ego(nodes_pupils$sex) + 
    ego(nodes_pupils$adhd) + 
    indeg(net_statements, isTwoMode = FALSE, weighted = TRUE, window = 3, type = "ego") +
    sim(nodes_pupils$adhd) + 
    tie(net_playmates, weighted = FALSE, window = 1, ignoreRep = TRUE) +
    recip(net_statements, weighted = TRUE, window = 3, ignoreRep = FALSE),
    model = "REM", subModel = "choice" #select the REM model and choice submodel
  )
summary(model_statement_REM)
```

<div class="question">
Exercises

1. A DyNAM model uses reciprocity to model only the statement target, not the speaker. In contrast, a REM uses reciprocity both to select the speaker and target. Which model is intuitively more plausible to you?
2. Run the code (if your computer is not too slow; alternative: only run the summary() function) and interpret the sign of the coefficients as increasing or decreasing the probability of a statement.
</div>

## Playmate coordination

The rate and choice models can only predict directed ties and interactions, where we can distinguish between sender and receiver.

In contrast, our playmate ties are undirected. We simply do not know who initiated the playmate tie ("Do you want to play with me?") and who accepted the invitation ("Yes, let's play together!").

The `goldfish` package offers a choice-coordination sub-model to analyze the change of undirected ties and interactions over time. It assumes that both actors involved decide whether or not to participate in the tie or interaction.

This model can handle all types of effects that are available in the package. It predicts which tie/interaction is started or ended (given that a tie/interaction has started or ended).

The effects are interpreted in the same way as in a DyNAM choice model.

```{r coordinationmodel1, exercise = TRUE}
# Estimate the probability (log odds) that two pupils start to play together.
# Step 1: Define the dependent events
events_play_dep <- defineDependentEvents(
  events = events_playmates[events_playmates$increment == 1,], #the event list that should be considered as a dependent variable in the model
  nodes = nodes_pupils, #data frame or a nodes.goldfish object containing the nodes used in the event list
  defaultNetwork = net_playmates #name of a goldfish network object
)
# NOTE: Within the tutorial, changes to the code of Step 1 are ignored.
# Step 2: Estimate the coordination model.
model_playmate_start <- estimate(
  events_play_dep ~ #do not use an intercept in a choice (coordination) model!
      same(nodes_pupils$sex) + 
      same(nodes_pupils$ethnicity) + 
      sim(nodes_pupils$adhd) + 
      tie(net_friends) + #friendship is static: don't use the 'window' argument
      indeg(net_playmates, isTwoMode = FALSE, weighted = TRUE, window = 3, type = "alter") + 
      trans(net_playmates, window = 3, ignoreRep = TRUE), 
    model = "DyNAM", subModel = "choice_coordination" #note the submodel
  )
summary(model_playmate_start)
```

<div class="question">
Exercises

1. Inspect the code of Step 2. Which effects are estimated and what do the arguments mean?

2. Run the code (may take some time; alternative: only run the summary() function) and inspect the output (in the last output box). Interpret the signs (directions) of the coefficients: What increases the probability that two pupils tart playing together, what decreases the probability?

3. Estimate some more models, adding/removing effects and changing arguments.
</div>

## `RSiena` for panel wave data

The models presented in the preceding topics all require data on events with more or less precise information on start and end times.

If the data is collected in panel waves, similar types of models can be estimated with the `RSiena` package.

`RSiena` uses the same logic and types of predictors as the DyNAM rate and choice models. It treats the events of tie or interaction starts and endings in between panel waves as missing data. The missing data are guessed by simulating the process of events in between panel waves.

Because of the guessing, `RSiena` requires that the ties do not change too much between subsequent panel waves. A substantial proportion of ties that exist in the a panel wave must still exist in the next. 

If the ties for which we want to predict change are durable in comparison to the time span between measurement waves, you can analyze the typs of effects learned here with the `RSiena` package.

## Conclusion

We have learned:

* What types of effects are used to predict network evolution;
* Which research questions can be answered by tests of these effects;
* How to estimate the effects with different models;
* How to globally interpret the results.

This concludes the tutorials on analyzing events within networks.

## Further Reading

- An explanation and example application of the rate and choice models can be found in: Stadtfeld, C., & Block, P. (2017). Interactions, Actors, and Time: Dynamic Network Actor Models for Relational Events. _Sociological Science_, 4, 318–352. https://doi.org/10.15195/v4.a14.
- Coordination models are introduced and applied in: Stadtfeld, C., Hollway, J., & Block, P. (2017). Dynamic Network Actor Models: Investigating Coordination Ties through Time. _Sociological Methodology_, 47(1), 1–40. https://doi.org/10.1177/0081175017709295.
- The seminal paper on relational events models: Butts, C. T. (2008). A relational event framework for social action. _Sociological Methodology_, 38(1), 155–200.
- An extensive manual for the `RSiena` package can be found at http://www.stats.ox.ac.uk/~snijders/siena/RSiena_Manual.pdf.
- An alternative approach based on event history models is offered in: de Nooy, W. (2011). Networks of action and events over time. A multilevel discrete-time event history model for longitudinal network data. _Social Networks_, 33(1), 31–40. https://doi.org/10.1016/j.socnet.2010.09.003.

## Appendix: Data preparation

This is an advanced topic that you should probably only study if you start working with your own data. Nevertheless, the comments may help you understand the contents of the data that we need for `goldfish`.

```{r dataprep, exercise=TRUE}
# Create the data sets for predicting statements and playmate ties with the
# goldfish package.

# Step 1: The node set and time-constant node characteristics or starting values for time-varying node characteristics.
# - Nodes are identified by textual labels (required). 
# - variable 'present' (required) indicates if a pupil was already present at
#   the first time point.
# - Add time-constant node characteristics or starting values for time-varying
#   node characteristics (if any). These can be used as attributes in the
#   construction of predictors.
# The basic data set pupils_const contains all information.
nodes_pupils <- pupils_const %>% 
  #sort by label to ensure the same order in all networks
  arrange(label) %>%
  #select relevant variables.
  select(label, present, sex, ethnicity, adhd)
# Turn the data frame into a nodes.goldfish data object.
nodes_pupils <- defineNodes(nodes = nodes_pupils)
print("Showing data set nodes_pupils:")
as_tibble(nodes_pupils)

# Step 2: The changes to node attributes (if any, optional) over time.
# We do not have time-varying node attributes.
# If we had, we should ave used the linkEvents() function with arguments
# changeEvents and attribute.

# Step 3. The static or starting networks. 
# One network for each type of tie or event. One of these is the
# dependent/outcome network, all can be used as independent/predictor networks.
# All networks must have the same nodes as the nodes set and ordered as in the
# nodes set created in Step 1.
# - The initially empty directed network of statements.
net_statements <- defineNetwork(nodes = nodes_pupils, directed = TRUE)
# - The initially empty undirected network of playmates.
net_playmates <- defineNetwork(nodes = nodes_pupils, directed = FALSE)
# - The static undirected network of friendships.
#   For a static network, create a 0/1 matrix with rows and columns in the same
#   order as in the list of nodes.
#   The matrix columns must have the node labels as dimnames, but the rows do
#   not need to have dimnames.
friends_matrix <- pairs_const %>%
  #keep only the sender and receiver
  select(from, to, friend) %>%
  #add labels to IDs (so goldfish can match the matrix to the nodes)
  left_join(pupils_const[,c("ID", "label")], by = c("from" = "ID")) %>%
  left_join(pupils_const[,c("ID", "label")], by = c("to" = "ID")) %>%
  #label.x is sender, label.y is receiver: sort to match the nodes
  arrange(label.x, label.y) %>%
  #put 'to' values in columns
  pivot_wider(
    id_cols = label.x,
    names_from = label.y, #receiver provides the new columns (variables)
    values_from = friend, #variable friend indicates 0/1 friendship
    values_fill = 0, #replace missing values (e.g., on the diagonal) by 0
    names_sort = TRUE #ensure that the columns are in the correct order
    ) %>%
  #drop the from variable (row 1 has ID 1, etc.)
  select(-label.x) %>%
  #turn into a matrix
  as.matrix()
# create the undirected network of friendships
net_friends <- defineNetwork(matrix = friends_matrix, nodes = nodes_pupils, directed = FALSE)
print("Showing data set net_friends:")
as_tibble(net_friends)
# Cleanup.
rm(friends_matrix)

# Step 4. The events that happen to the networks. 
# Create a list of events for each network, indicating when an event starts or
# stops. Note: event start and end must become different rows (observations).
# One of these lists contains the events that we want to predict.
# Each events list must contain the variables: 
# - time: POSIXct, integer, or numeric (with decimals), 
# - sender: character label that occurs in nodes_pupils,
# - receiver: character label that occurs in nodes_pupils, 
# - increment: create (1) or dissolve (-1) event (numeric). Instead of
#   increment: replace, which updates the value of an attribute or tie (pair)?

# A. statement events
events_statements <- pairs_dyn %>%
  #select utterances in Break 1
  filter(dyntie == "Utterance" & breakID == 1) %>%
  #add labels to IDs (so goldfish can match the matrix to the nodes)
  left_join(pupils_const[,c("ID", "label")], by = c("from" = "ID")) %>%
  left_join(pupils_const[,c("ID", "label")], by = c("to" = "ID")) %>%
  #rename onset and terminus
  rename(
    onset.time = onset,
    terminus.time = terminus
  ) %>%
  #stack onset and terminus
  pivot_longer(
    cols = onset.time:terminus.censored,
    names_to = c("type", ".value"),
    names_sep = "\\.",
    values_drop_na = TRUE
  ) %>%
  #filter out censored end times (in case we want to predict end times)
  filter(!censored | type == "onset") %>%
  #recode increment into 1 for onset and -1 for terminus
  mutate(increment = ifelse(type == "onset", 1, -1)) %>%
  #select and rename relevant variables
  select(time, sender = label.x, receiver = label.y, increment) %>%
  #order by time
  arrange(time) %>%
  #a tibble throws a warning (in tutorial): Unknown or uninitialised column: `replace`.
  as.data.frame()
# link events to the network
net_statements <- linkEvents(x = net_statements, changeEvents = events_statements, nodes = nodes_pupils)
print("Showing data set events_statements:")
as_tibble(events_statements)

# B. playmate events
events_playmates <- pairs_dyn %>%
  #select playmate cases in Break 1 and only one row for each pair (undirected data)
  filter(dyntie == "Playmate" & breakID == 1 & from < to) %>%
  #add labels to IDs (so goldfish can match the matrix to the nodes)
  left_join(pupils_const[,c("ID", "label")], by = c("from" = "ID")) %>%
  left_join(pupils_const[,c("ID", "label")], by = c("to" = "ID")) %>%
  #rename onset and terminus
  rename(
    onset.time = onset,
    terminus.time = terminus
  ) %>%
  #stack onset and terminus
  pivot_longer(
    cols = onset.time:terminus.censored,
    names_to = c("type", ".value"),
    names_sep = "\\.",
    values_drop_na = TRUE
  ) %>%
  #filter out censored end times (there aren't any)
  filter(!censored | type == "onset") %>%
  #recode increment into 1 for onset and -1 for terminus
  mutate(increment = ifelse(
    type == "onset", 1, -1
  )) %>%
  #select and rename relevant variables
  select(time, sender = label.x, receiver = label.y, increment) %>%
  #order by time
  arrange(time) %>% #a tibble throws a warning (in tutorial): Unknown or uninitialised column: `replace`.
  as.data.frame()
# link events to the network
net_playmates <- linkEvents(x = net_playmates, changeEvents = events_playmates, nodes = nodes_pupils)
print("Showing data set events_playmates:")
as_tibble(events_playmates)
```

